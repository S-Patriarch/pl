/*
 * Copyright (C) 2025, S-Patriarch
 * Patriarch library : pl::Logger
 *
 * write() - запись строки в журнал логов
 * read() - чтение строки из журнала логов
 */

#ifndef PL_LOGGER
#define PL_LOGGER 1

#ifndef PL_EXCEPTION
#include "pl.exception"
#endif

#include <fstream>
#include <iostream>
#include <string>
#include <mutex>
#include <shared_mutex>

namespace pl {

    using std::string;

    class Logger {
        std::fstream      m_file;  // файловый поток
        std::shared_mutex m_mutex; // мьютекс

    public:
        Logger(const string &);
        ~Logger() noexcept;

        auto write(const string &) -> void;
        auto read() -> string;
    };

    Logger::Logger(const string &s_flog)
    {
        // открытие файла для чтения, вывода,
        // добавления с отключенной буферизацией
        m_file.open(s_flog, std::ios::in|std::ios::out|std::ios::app);
        if (!m_file.is_open())
            throw Exception("E: failed to open log file.");
    }

    Logger::~Logger() noexcept
    {if (m_file.is_open()) m_file.close();}

    auto Logger::write(const string &s) -> void
        // запись строки в журнал логов
        // создание объекта lck типа std::unique_lock, который блокирует
        // мьютекс m_mutex в режиме монопольной (или уникальной) блокировки
        // это значит, что только один поток может иметь доступ к общему
        // ресурсу, защищенному m_mutex, в данный момент времени
        // объект lck будет автоматически освобожден при выходе из
        // области видимости
    {
        std::unique_lock<std::shared_mutex> lck(m_mutex);
        if (m_file.is_open()) {
            m_file
                << s
                << "\n"
                << std::flush;
        }
    }

    auto Logger::read() -> string
        // чтение строки из журнала логов
        // создание объекта lck типа std::shared_lock, который блокирует
        // мьютекс m_mutex в режиме совместной блокировки
        // это позволяет нескольким потокам иметь одновременный доступ к
        // общему ресурсу
        // объект lck будет автоматически освобожден при выходе из
        // области видимости
    {
        string s_res {};
        std::shared_lock<std::shared_mutex> lck(m_mutex);
        if (m_file.is_open()) std::getline(m_file, s_res);
        return s_res;
    }

}

#endif
